const fs = require('fs');
const outdent = require('outdent');
const schema = require('../src/data/schema.js');
const outfile = `src/generated/runtime.gen.bash`;

const ind = ` `.repeat(2); // for inside methods
// const ind2 = ` `.repeat(4);
let file = `# This file is generated by ${__filename}\n\n`;

const utils = `
${fs.readFileSync('scripts/helpers/s_parse_json.bash', 'utf-8')}
`;

file += `${utils}\n`;

function processSchema(field, state = {
  res: { pathsToFields: {}, jqBody: {} },
  parentKeyPath: '',
  parentBody: null,
  parentBodyKey: null,
}) {
  /* eslint-disable */
  const { res, parentKeyPath, parentBody = {}, parentBodyKey } = state;
  const jqName = parentKeyPath.split(/[^A-Za-z0-9]+/g).join('_');

  if (field.type === 'object') {
    Object.keys(field.properties).forEach((key) => {
      const childBody = {};
      if (!parentBody) {
        res.jqBody[key] = jqName;
      }
      res.pathsToFields[parentKeyPath] = { asJson: true, type: 'object', jqName };
      const newKey = parentKeyPath ? `${parentKeyPath}.${key}` : key;

      const newBody = {};

      processSchema(field.properties[key], {
        res,
        parentKeyPath: newKey,
        parentBody: childBody,
        parentBodyKey: key,
      });
    });
  }
  if (field.type === 'number') {
    parentBody[parentBodyKey] = `$${jqName}`;
    res.pathsToFields[parentKeyPath] = { asJson: true, type: 'number', jqName };
  }
  if (field.type === 'string') {
    parentBody[parentBodyKey] = `$${jqName}`;
    res.pathsToFields[parentKeyPath] = { asJson: false, type: 'string', jqName };
  }
  /* eslint-enable */
  return state.res;
}

let methods = [];
// let docs = [];
schema.operations.forEach((op) => {
  // eslint-disable-next-line
  const { name, input, output } = op;
  const funcName = `ide_` + name.replace(/[A-Z0-9]/g, x => `_${x.toLowerCase()}`);

  const { pathsToFields, jqBody } = processSchema(input);

  console.log(jqBody);

  let method = ``;
  method += `function ${funcName} () {\n`;


  const makeJqArgs = Object.keys(pathsToFields).map((path) => {
    const opts = pathsToFields[path];
    let opt = ``;
    opt += `if [[ '$key' == '${path}' ]]; then\n`
    if (opts.asJson) {
      opt += `${ind}jq_args+=(--argjson)\n`;
    } else {
      opt += `${ind}jq_args+=(--arg)\n`;
    }
    opt += `${ind}jq_args+=(${opts.jqName})\n`;
    opt += `${ind}jq_args+=("$value")\n`;

    return opt;
  })
    .filter(Boolean)
    .map(x => `${ind}${x}`)
    .join('\n');

  const body = outdent`
  local jq_args
  jq_args=()

  for arg in "$@"; do
    local key
    local value
    local parts=()
    local parts_length

    IFS=$'\v' read -a parts <<<"$(printf '%s' "$arg" | sed 's/./&\v/')"
    key="\${parts[0]}"
    parts_length="\${#parts[@]}"

    if [[ "$parts_length" != '2' ]]; then
      printf 'Function ${funcName} for option "%s" must be in the format "%s=somevalue"' "$key" "$key"
    fi

    value="\${parts[1]}"

    ${makeJqArgs}

    jq "\${jq_args[@]}"
  done
  `;

  method += body;
  method += `}`;
  return method;
});

file += methods.join('\n\n');
console.log(file);
fs.writeFileSync(outfile, file);
